# JWTシグネチャエラーのデバッグ記録

## 発生している問題

Supabaseクライアントがデータベースにアクセスする際に、以下のJWT署名エラーが発生しています：

```
エラーコード: PGRST301
メッセージ: JWSError JWSInvalidSignature
ステータス: 401 Unauthorized
```

特に`apps/web/actions/metric/metrics.ts`ファイル内の`getMetrics()`関数でmetricsテーブルにアクセスする際に発生しています。

## 解決アプローチと結果チェックリスト

### 実施済みの対応

- [x] **サービスロールクライアントへのフォールバック実装**
  - getSupabaseServerClient()でエラー発生時、getSupabaseServerAdminClient()を使用
  - サービスロールクライアントはRLSをバイパスするため、認証エラーが発生しない
  - 結果: 開発環境で正常に動作し、機能的に問題なし（ただしセキュリティ面での懸念あり）

- [x] **環境変数の統一化**
  - Dockerコンテナ内と.env.localファイルの間のSupabase URL設定を統一
  - 環境変数に記載されたコマンド部分を削除
  - 結果: 関連する環境変数は正しく設定されたが、JWT署名エラーは解消せず

- [x] **Supabase設定ファイル修正**
  - config.tomlから無効なjwt_secret設定を削除
  - Supabaseの再起動で変更を適用
  - 結果: 設定は適用されたがJWTエラーは継続

- [x] **認証関連のCookie設定追加**
  - Docker環境向けにCookieドメイン（.saedgewell.test）設定
  - サイトURL（http://web.saedgewell.test）の明示的指定
  - 結果: 認証フローは改善されたがJWTエラーは継続

- [x] **JWT検証の詳細ログ取得**
  - 作成したjwt-debug.shスクリプトを実行して詳細ログを分析
  - Supabaseのログレベルを上げて認証プロセスを詳細に確認
  - 結果: Supabase CLI 2.19.7では`logs`コマンドがサポートされていない

- [x] **匿名アクセスを許可するRLSポリシーの改善**
  - 特定のテーブル（metrics）に対して匿名ユーザーの読み取りを許可するRLSポリシーを追加
  - 結果: RLSポリシーは設定できたが、JWT署名エラーが継続し標準クライアントからのアクセスは依然として不可

### 新たな解決策

- [ ] **PostgreSQLのデータベース設定でJWT秘密鍵を直接設定**
  - 問題: SQLエディターで`ALTER DATABASE postgres SET "app.settings.jwt_secret" TO 'super-secret-jwt-token-with-at-least-32-characters-long';`を実行すると、権限エラーが発生
  - エラー: `ERROR: 42501: permission denied to set parameter "app.settings.jwt_secret"`
  - 解決案:
      1. **Dockerコンテナ内でpsqlコマンドを使用して直接設定する**
         - `docker-compose exec supabase-db psql -U postgres -c "ALTER DATABASE postgres SET \"app.settings.jwt_secret\" TO 'super-secret-jwt-token-with-at-least-32-characters-long';"`

      2. **Base64エンコードされたJWT秘密鍵を使用する**
         - 環境変数のJWT秘密鍵をBase64エンコードした値に変更: `c3VwZXItc2VjcmV0LWp3dC10b2tlbi13aXRoLWF0LWxlYXN0LTMyLWNoYXJhY3RlcnMtbG9uZw==`
         - Docker-composeファイルのSUPABASE_AUTH_JWT_SECRET環境変数を更新

      3. **Supabaseの再起動とキャッシュクリア**
         - 全てのDockerコンテナを再起動: `docker-compose down && docker-compose up -d`
         - 必要に応じてJWTキャッシュもクリア

## 根本原因について

詳細な調査の結果、次の点が判明しました：

1. **データベースとJWTマッチング問題**:
   - **Supabase APIと認証サービスで使用されるJWT秘密鍵** と **PostgreSQL/PostgRESTが内部で使用するJWT秘密鍵** が一致していない可能性が高い
   - これにより、API層で生成されたJWTトークンがPostgRESTレイヤーで検証に失敗している

2. **Docker環境特有の問題**:
   - Docker内のPostgREST設定では、データベースから`app.settings.jwt_secret`パラメータを読み取る
   - この設定がDocker環境内で適切に反映されていない可能性がある

3. **認証フローの問題**:
   - Dockerコンテナ内からNext.jsサーバーコンポーネントが実行される際、セッションが正しく初期化されていない
   - JWT署名検証エラーが発生する前に、そもそもセッションが存在しない状態

4. **権限の問題**:
   - SQLエディターからの実行ではデータベースパラメータ変更の権限が不足している
   - Dockerコンテナ内でpsqlコマンドを直接実行すれば、適切な権限で設定を変更できる

## 現在の実装状態

本プロジェクトは現在以下の状態で動作しています：

1. **現状の動作状況**:
   - サービスロールクライアントへのフォールバックにより、アプリケーションは正常に動作
   - 匿名ユーザー用のRLSポリシーは設定したが、JWT署名エラーにより効果が出ていない
   - 開発環境では問題なく動作するため、開発作業は継続可能

2. **本番環境に向けた最適解**:
   - JWT署名エラーの根本解決が最も望ましいが、複雑なDocker環境と認証フローが原因

3. **提案される最終方針**:
   - **開発環境**: 現状のフォールバックメカニズムを維持し、開発作業を継続
   - **テスト/ステージング環境**: 本番設定のテストを行い、JWT署名の検証を確認
   - **本番環境**: 適切なRLSポリシーを持つ標準クライアント実装に移行

## 今後の対応

1. 提案した解決策を試して、JWT署名エラーが解消されるか確認する
2. 根本的な解決のため、Supabase設定ファイルとPostgreSQL設定の整合性を確保する
3. 長期的には、JWTキー管理を自動化するスクリプトやマイグレーションツールの開発を検討する

その他の将来的な課題：

- [ ] **Supabase環境の再構築**
  - 次回の大きなアップデート時にSupabaseのローカル開発環境を完全に再構築
  - 環境変数と設定ファイルの一貫性を確保

- [ ] **サーバークライアント実装の詳細分析**
  - getSupabaseServerClientの実装やSSRパッケージの動作を詳細に分析
  - Next.jsのcookies APIとSupabaseの認証フローの整合性を確認

- [ ] **テスト用JWTトークンの生成と検証**
  - テスト用のJWTトークンを生成して署名検証をテスト
  - JWT署名アルゴリズムやキーの形式に問題がないか確認

- [ ] **セキュアなフォールバック戦略の検討**
  - 本番環境に対応したセキュアなフォールバックメカニズムの設計
  - 匿名ユーザーに必要最小限の権限を付与するRLSポリシーの再確認

- [ ] **標準クライアントのみの実装へのリファクタリング**
  - JWT問題解決後、サービスロールクライアントへのフォールバックを削除
  - 適切なエラーハンドリングを実装

## セキュリティ上の注意点

1. JWT秘密鍵はセキュリティ上重要な情報であり、適切に管理する必要がある
2. 本番環境では、生成されたランダムな値を使用し、開発環境のテスト用の値は使用しない
3. サービスロールクライアントへのフォールバックは一時的な対応であり、本番環境では標準クライアントを使用するよう改善する

## まとめ

現在の実装では、サービスロールクライアントへのフォールバックにより、アプリケーションは開発環境で問題なく動作しています。JWT署名エラーの根本原因は、JWTキーの不一致、Docker環境特有の設定問題、セッション初期化の問題など複合的です。開発を継続するためには現状の実装で問題ありませんが、本番環境での運用前にJWT認証フローを修正するか、適切なRLSポリシーを設計して標準クライアントのみの実装に移行することが推奨されます。 